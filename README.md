> **Дисклеймер**: данная программа, возможно, представляет из себя просто огромную свалку велосипедов и костылей, но я на это срал, т.к. и так сойдет, и пишу ее для себя.

Что тут?
---------
Что-то вроде умного дома с модульной структурой.

Интеграция 
----------

```
[+]  TCP/IP Socket
[-]  DLNA
[-]  MPRIS2
[-]  libtorrent / libaria2
[-]  D-Bus
[+]  xsel
[-]  PushBullet
[-]  Google Календарь
[+]  Вконтакте
[-]  QIWI и кредитки
[-]  sms-reg и подобное
[-]  GPG / GnuPG
[-]  XMPP
[-]  Google Search | Yandex Search | Duck Duck Go
[-]  Prosto Pleer | Youtube
[-]  Gracenote | Shazam | SoundHound | acoustid
[-]  Weather.com | Forecast.io | Openweathermap | Narodmon
[+]  Base64, hex
[+]  Google Speech API | Yandex Speech API
[-]  UPNP (https://gist.github.com/acacio/1603181)
```

Типы модулей
------------

-  ```IO``` - связь, позволяющая передавать логические утверждения (пример: голосовой интерфейс, чат) в обе стороны
- ```Sense``` - источники информации (поиск, текст на экране aka xsel, погода, вики), у которых можно запросить текущее состояние
- ```Notify``` - уведомления, позволяющие передавать произвольные данные, априори не требующие ответа (push уведомления, запись в буфер выделенного текста иксов aka xsel)
- ```Action``` - действия, которые может совершить ии (управление медиа, светом, системой)
- ```Memory``` - read-only хранилища информации (как и произвольной, так и логических утверждений и шаблонов)
- ```PrivateMemory``` - хранилища персональной информации ИИ.
- ```Security``` - политики доступа к информации
- ```Parser``` - парсеры произвольных данных, то же что и Action, но действия выполняются над некоторыми данными
- ```Lang``` - преобразует внутренний формат в человекопонятный и наоборот
- ```Brain``` - реагирует на поступающую информацию
- ```Core``` - функции ядра
- ```Lib``` - вспомогательные фичи
- ```Data``` - источники произвольных данных и медиа
- ```Monitor``` - отслеживает события

> Модули ```core.[brain|lang|action|...]``` загружаются после всех модулей выбраной категории, так что если нужно добавить в зависимости все модули, например, ```brain.*```, то следует добавить один только ```core.brain```. 

Интерфейсы 
----------

```
class Message (string data, object session){
	method toString()
	[object context]
}

class Session extends EventEmitter () {
	method send(Message, callback(error))
	event message Message
	event end
	bool ended
}

class io extends EventEmitter {
	event session Session
	array sessions
}

class sense {
	method readState (callback(error, data))
}

class notify {
	// callback вызывается если сообщение не дошло (error) или было прочитано ().
	method notify(message, callback(error))
}
```

Структура: IO
-------------
**Использует**: ```core.namespace```, ```core.lang```   
**Используется**: ```core.io```

> Представляет какой-либо двусторонний канал связи, пригодный для общения. Не использует другие модули (кроме lib.* и core.namespace, разумеется), загружается перед core.io, и это нужно прописывать в манифесте.

**При инициализации**:
 - начать слушать входящие запросы

> (сессия всегда открывается клиентом, в ином случае сначала работает Notify, а затем клиент обращается. Клиент может указать, что отвечает на запрос (Notify), и это будет зафиксировано в состоянии сессии)

**При открытии канала сообщения**:
- добавить объект Session в массив api.io.sessions
- создать событие 'session' на api.io
- установить метод send

**При новом сообщении**:
- создать событие 'message' на объекте сессии, как параметр передав объект Message

**При закрытии канала сообщения**:
- убрать объект сессии из массива api.io.sessions
- создать событие 'end' на объекте сессии
- установить параметр ended объекта сессии в положительное состояние


Структура: Sense
----------------
**Использует**: ```core.namespace```   
**Используется**: core.sense

> Представляет какой-либо сенсор, у которого можно получить информацию о текущем состоянии в любой момент. 

**При инициализации**:
- создать объект, имплементирующий Sense
  - свойство readState - функция, возвращающая в коллбек состояние сенсора
- добавить объект в api.sense.


Структура: Notify
-----------------
**Использует**: ```core.namespace```   
**Используется**: ```core.notify```

> Представляет исходящий канал данных, позволяющий уведомить пользователя. 

**При инициализации**:
- создать объект, имплементирующий ```Notify```
- свойство ```notify``` - функция, возвращающая в коллбек ошибку в случае неотправки, и ничего в случае успешной отправки/прочтения.
- добавить объект в ```api.notify```

Структура: Action
-----------------
**Использует**: ```core.namespace```   
**Используется**: ```core.action```

> Представляет собой канал управления чем-либо, позволяющий выполнять действия над определенным объектом. Можно разделить на части, а отсылать команды через библиотечный модуль (```lib.*```), если есть смысл разделять команды (например, модуль управления умным домом можно разделить на части: свет, отопление, чайник, ..., (lib)шина управления 1-wire) 

**При инициализации**:
- создать объект, имплементирующий Action
- свойство ```do``` - функция ```(params, callback)```, возвращающая в коллбек ошибку в случае невыполнения, и ничего в случае успешного завершения. Можно передавать последующими аргументами какие-либо данные, если необходимо, но вообще рекомендуется использовать для такого отдельные модули вида Monitor и Sense. 

Структура: Memory
-----------------
**Использует**: ```core.namespace```   
**Используется**: ```core.memory```

> Представляет собой базу каких-либо данных (Read-Only). Данные хранятся (ну или хотя-бы преобразуются при получени) в формате RDF.

**При инициализации**:
- создать объект, имплементирующий ```Memory```
- свойство get - функция ```(params, callback)```, возвращающая в коллбэк ошибку или null первым аргументом и массив объектов RDF вторым.

Структура: PrivateMemory
------------------------
**Использует**: ```core.namespace```, ```core.security```   
**Используется**: ```core.privateMemory```

> Представляет собой базу персональных данных Искусственного Интеллекта (Read-Write). Данные хранятся в формате RDF, но каждый триплет имеет ID, что позволяет триплету ссылаться на другой триплет. Так становится возможным управление приватными данными (кому можно доверять). 

**При инициализации**:
 - создать объект, имплементирующий ```PrivateMemory```
 - свойство ```get``` - функция ```(params, callback)```, возвращающая в коллбек ошибку первым аргументом и массив RDF вторым. Помимо результатов запроса так же возвращаются триплеты, описывающие свойства возвращенных триплетов. Глубина не ограничена (возможно указывать свойства свойств свойств триплетов и так далее).
 - свойство ```set``` - функция ```(params, callback)```, возвращающая в коллбэк ошибку первым аргументом в случае неудачи и ID триплета вторым в случае успеха.


Структура: Brain
----------------
**Использует**: ```core.namespace```    
**Используется**: ```core.brain```

> Представляет собой обработчик входных данных, решающий, что делать в ответ на поступающие данные. Каждый такой модуль обрабатывает данные своего типа, например, ```brain.talk``` занимается обработкой диалогов.

**При инициализации**:
 - Поставить свой обработчик событий на источник данных


Ввод данных (Эсперанто)
-----------

1. Ввод прямых данных.
	1. Сырой уровень (вербальная речь, письменная, мысли и прочее)
	2. Цифровой уровень
	3. Текстовой уровень
	4. Синтаксическое дерево 
	5. Логическое дерево
2. Импорт баз знаний.
	1. Цифровой уровень
	2. Абстрактный промежуточный
	3. Логическое дерево
3. Ввод динамических данных. (Поиск Google, etc)
	1. @Построение прямых данных
	2. Получение данных поисковика
	3. Получение веб-страниц
	4. Получение истории изменений
	5. Синтаксическое дерево 
	6. Логическое дерево
4. Ввод динамических данных. (Датчики, камеры, etc)
	1. Цифровой уровень
	2. Абстрактный промежуточный
	3. Логическое дерево

Хранение данных
---------------

Данные в структурированном виде хранятся в СУБД.
Доступ к СУБД осуществляется косвенно, т.е. через прослойку.

Обработка данных
----------------

Данные поступают на вход шаблонного сканера, и если найдено подходящее условие, то обработка передается соответствующей функции.
Если данные не были восприняты шаблонизатором, то они поступают на вход ИНС. 
Формат данных для ИНС - @под вопросом.
Выход ИНС проверяется на значимость (риск), если он
 превышает норму, то решение передается Админу.
ИНС может отправить запрос к модулю, затем она будет вызвана заново с данными от модуля вместе с исходными данными (см. Нейронная сеть Джордана, нейронная сеть Элмана). (Возможно так же рекуррентный возврат значения от модуля в текущий инстанс НС)

Вывод данных
------------

- Прямой вывод данных
	1. Логическое дерево
	2. Синтаксическое дерево
	3. Текст (со словарем синонимов)


Безопасность
------------

* **Аутентификация**
Используются все возможные методы, получая в итоге коэффициент подтвержденности личности.
= % пройденных тестов / обычный %

* **Коэффициент доверия на текущий момент** (к текущей сессии)
= коэффициент для текущего собеседника * на коэффициент подтвержденности личности (защищенность канала)

* **Коэффициент доверия к определенному собеседнику** (источнику информации)
Используется сеть доверия.
Коэффициент может изменяться. При несоответствии фактов коэффициент падает. При соответствии фактов с иными источниками, коэффициент растет. 
= коэфф. пригласившего человека * k ./ 30300

* **Группы**
Если идет контакт сразу с несколькими людьми, то доверие становится минимальным из всех людей.

* **Секреты**
Некоторые факты в базе данных могут быть отмечены, чтобы к ним могли иметь доступ только определенные группы людей. 
