Краткая инструкция по созданию модуля.
======================================

Содержание:
-----------

* Типы модулей
* Манифест
* Рецепты

Типы модулей
------------

-  ```IO``` - связь, позволяющая передавать логические утверждения (пример: голосовой интерфейс, чат) в обе стороны
- ```Sense``` - источники информации (поиск, текст на экране aka xsel, погода, вики), у которых можно запросить текущее состояние
- ```Notify``` - уведомления, позволяющие передавать произвольные данные, априори не требующие ответа (push уведомления, запись в буфер выделенного текста иксов aka xsel)
- ```Action``` - действия, которые может совершить ИИ (управление медиа, светом, системой)
- ```Memory``` - read-only хранилища информации (как и произвольной, так и логических утверждений и шаблонов)
- ```PrivateMemory``` - хранилища персональной информации ИИ (личные поручения, коэффициенты доверия, непубличные данные о людях)
- ```Security``` - политики доступа к информации, используется совместно с ```PrivateMemory```
- ```Parser``` - парсеры произвольных данных, то же что и ```Action```, но действия выполняются над некоторыми данными
- ```Lang``` - преобразует внутренний формат в человекопонятный и наоборот
- ```Brain``` - реагирует на поступающую информацию, например, ```brain.talk``` реагирует на поступающие сообщения и решает, что с ними делать. 
- ```Core``` - функции ядра
- ```Lib``` - вспомогательные фичи, так же тут следует хранить куски кода, используемые несколько раз, а так же если два модуля требуют один канал связи. 
- ```Data``` - источники произвольных данных и медиа (погода, файлообменники)
- ```Monitor``` - отслеживает события, по сути ```EventEmitter```

> Модули ```core.[brain|lang|action|...]``` загружаются после всех модулей выбраной категории, так что если нужно добавить в зависимости все модули, например, ```brain.*```, то следует добавить один только ```core.brain```. 

Манифест
--------

> Манифест дает загрузчику знать, в каком порядке запускать модуль. В манифесте указываются модули, которые запускаются строго до или строго после данного, а так же главный файл, название и описание модуля. 

Пример манифеста:
```javascript
{
	"name": "io.example",
	"desc": "Тестовый модуль ввода-вывода",
	"main": "index.js",

	// Необходимые для запуска файлы
	"deps_files": [
		"/usr/bin/echo"
	],

	// То, что будет загружено после этого модуля
	"before": [
		"core.io"
	],

	// То, что будет загружено до этого модуля
	"deps": [
		"core.namespace",
		"lib.simplify"
	],

	// Требуемые модули NPM
	"deps_npm": [
		{
			"name": "request",
			"version": ">= 2.64.0",
			// если true, то пакет может быть использован другими модулями
			"shared": true
		}
	]    
} 
```

> Манифест и главный файл может быть создан так же утилитой ```addmod```.

Рецепты
-------

# Внимание! Информация ниже является устаревшей.

### Рецепт: IO
**Использует**: ```core.namespace```, ```core.lang```   
**Используется**: ```core.io```

> Представляет какой-либо двусторонний канал связи, пригодный для общения. Не использует другие модули (кроме ```lib.*``` и ```core.namespace```, разумеется), загружается перед ```core.io```, и это нужно прописывать в манифесте.

**При инициализации**:
 - начать слушать входящие запросы

> (сессия всегда открывается клиентом, в ином случае сначала работает ```Notify```, а затем клиент обращается. Клиент может указать, что отвечает на запрос (```Notify```), и это будет зафиксировано в состоянии сессии)

**При открытии канала сообщения**:
- добавить объект ```Session``` в массив ```api.io.sessions```
- создать событие ```session``` на ```api.io```
- установить метод ```send```

**При новом сообщении**:
- создать событие ```message``` на объекте сессии, как параметр передав объект Message

**При закрытии канала сообщения**:
- убрать объект сессии из массива ```api.io.sessions```
- создать событие ```end``` на объекте сессии
- установить параметр ended объекта сессии в положительное состояние


### Рецепт: Sense
----------------
**Использует**: ```core.namespace```   
**Используется**: ```core.sense```

> Представляет какой-либо сенсор, у которого можно получить информацию о текущем состоянии в любой момент. 

**При инициализации**:
- создать объект, имплементирующий ```Sense```
  - свойство ```readState``` - функция, возвращающая в коллбек состояние сенсора
- добавить объект в ```api.sense```.


### Рецепт: Notify
**Использует**: ```core.namespace```   
**Используется**: ```core.notify```

> Представляет исходящий канал данных, позволяющий уведомить пользователя. 

**При инициализации**:
- создать объект, имплементирующий ```Notify```
  - свойство ```notify``` - функция, возвращающая в коллбек ошибку в случае неотправки, и ничего в случае успешной отправки/прочтения.
- добавить объект в ```api.notify```

### Рецепт: Action
**Использует**: ```core.namespace```   
**Используется**: ```core.action```

> Представляет собой канал управления чем-либо, позволяющий выполнять действия над определенным объектом. Можно разделить на части, а отсылать команды через библиотечный модуль (```lib.*```), если есть смысл разделять команды (например, модуль управления умным домом можно разделить на части: свет, отопление, чайник, ..., (lib)шина управления 1-wire) 

**При инициализации**:
- создать объект, имплементирующий ```Action```
  - свойство ```do``` - функция ```(params, callback)```, возвращающая в коллбек ошибку в случае невыполнения, и ничего в случае успешного завершения. Можно передавать последующими аргументами какие-либо данные, если необходимо, но вообще рекомендуется использовать для такого отдельные модули вида ```Monitor``` и ```Sense```. 

### Рецепт: Memory
**Использует**: ```core.namespace```   
**Используется**: ```core.memory```

> Представляет собой базу каких-либо данных (Read-Only). Данные хранятся (ну или хотя-бы преобразуются при получени) в формате RDF.

**При инициализации**:
- создать объект, имплементирующий ```Memory```
  - свойство get - функция ```(params, callback)```, возвращающая в коллбэк ошибку или ```null``` первым аргументом и массив объектов RDF вторым.

### Рецепт: PrivateMemory
-------**Использует**: ```core.namespace```, ```core.security```   
**Используется**: ```core.privateMemory```

> Представляет собой базу персональных данных Искусственного Интеллекта (Read-Write). Данные хранятся в формате RDF, но каждый триплет имеет ID, что позволяет триплету ссылаться на другой триплет. Так становится возможным управление приватными данными (кому можно доверять). 

**При инициализации**:
- создать объект, имплементирующий ```PrivateMemory```
  - свойство ```get``` - функция ```(params, callback)```, возвращающая в коллбек ошибку первым аргументом и массив RDF вторым. Помимо результатов запроса так же возвращаются триплеты, описывающие свойства возвращенных триплетов. Глубина не ограничена (возможно указывать свойства свойств свойств триплетов и так далее).
  - свойство ```set``` - функция ```(params, callback)```, возвращающая в коллбэк ошибку первым аргументом в случае неудачи и ID триплета вторым в случае успеха.


### Рецепт: Brain
----------------
**Использует**: ```core.namespace```    
**Используется**: ```core.brain```

> Представляет собой обработчик входных данных, решающий, что делать в ответ на поступающие данные. Каждый такой модуль обрабатывает данные своего типа, например, ```brain.talk``` занимается обработкой диалогов.

**При инициализации**:
- Поставить свой обработчик событий на источник данных
